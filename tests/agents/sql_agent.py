import os
import snowflake.connector
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from state import AgentState, create_agent_state
from enum import Enum
from typing import Any, Tuple

load_dotenv()

class SQLExecutionErrorType(Enum):
    SYNTAX_ERROR = "syntax_error"
    INVALID_IDENTIFIER = "invalid_identifier"
    PERMISSION_ERROR = "permission_error"
    CONNECTION_ERROR = "connection_error"
    OTHER = "other"

class SQLAgent:
    def __init__(self, model="gpt-4"):
        self.conn = self.snowflake_setup()
        self.llm = ChatOpenAI(model=model, temperature=0)
        self.prompt = ChatPromptTemplate.from_messages([
            (
                "system", 
                "You are an expert SQL query generator for Snowflake. Given a user query, database schema, "
                "and relevant course codes from course_description_results (generated by matching description with a vector match), "
                "generate only the SQL query to answer the user's question. Do not include any explanations or additional text. "
                "Avoid generating any INSERT, DELETE, CREATE, or ALTER statements. If provided, use course codes directly and "
                "avoid using LIKE clauses for course name matching. Course codes will typically follow the format 'INFO 4301', "
                "but the user might provide them without a space, such as 'INFO4301'. Recognize and handle such cases by ensuring "
                "the correct format with a space before querying the database. The term format follows 'Season Year Semester' "
                "(e.g., 'Spring 2025 Semester'). The current term is 'Fall 2024 Semester', and the upcoming term is 'Spring 2025 Semester'."
            ),
            (
                "user", 
                "User Query: {query}\n\n"
                "Database Schema:\n{schema}\n\n"
                "Relevant Course Codes: {course_codes}\n\n"
                "Generate only the SQL query to answer the user's question. "
                "Remember to use the correct term format (e.g., 'Spring 2025 Semester' for the upcoming term) when querying the CLASSES table, "
                "and check the schema and perform joins. Avoid using INSERT, DELETE, CREATE, or ALTER statements. "
                "If the course codes are provided without a space (e.g., 'INFO4301'), ensure they are correctly formatted (e.g., 'INFO 4301'). "
                "Note that the current term is 'Fall 2024 Semester' and the upcoming term is 'Spring 2025 Semester'."
            )
        ])



        self.tables = [
            "PROGRAM_REQUIREMENTS", "CORE_REQUIREMENTS", "CORE_OPTIONS_REQUIREMENTS",
            "SUBJECT_AREAS", "USER_COURSES", "USER_ELIGIBILITY", "ELECTIVE_REQUIREMENTS",
            "COURSE_CATALOG", "CLASSES"
        ]

    def snowflake_setup(self):
        return snowflake.connector.connect(
            user=os.getenv("SNOWFLAKE_USER"),
            password=os.getenv("SNOWFLAKE_PASSWORD"),
            account=os.getenv("SNOWFLAKE_ACCOUNT"),
            warehouse=os.getenv("SNOWFLAKE_WAREHOUSE", "WH_NEU_SA"),
            database=os.getenv("SNOWFLAKE_DATABASE", "DB_NEU_SA"),
            schema=os.getenv("SNOWFLAKE_SCHEMA", "NEU_SA"),
            role=os.getenv("SNOWFLAKE_ROLE"),
        )

    def get_schema(self) -> str:
        cursor = self.conn.cursor()
        schema = ""
        try:
            for table in self.tables:
                cursor.execute(f"DESCRIBE TABLE {table}")
                table_schema = cursor.fetchall()
                schema += f"Table: {table}\n"
                schema += "\n".join([f"{col[0]} {col[1]}" for col in table_schema])
                schema += "\n\n"
            return schema
        finally:
            cursor.close()

    def db_query(self, query: str):
        cursor = self.conn.cursor()
        try:
            print(query)
            cursor.execute(query)
            return cursor.fetchall()
        except Exception as e:
            return {"error": f"Query execution failed: {e}"}
        finally:
            cursor.close()

    def generate_query(self, user_query: str, schema: str, course_codes: list) -> str:
        response = self.llm.invoke(self.prompt.format(
            query=user_query,
            schema=schema,
            course_codes=", ".join(course_codes)
        ))
        return response.content.strip()

    def classify_error(self, error_message: str) -> SQLExecutionErrorType:
        if "syntax error" in error_message.lower():
            return SQLExecutionErrorType.SYNTAX_ERROR
        elif "invalid identifier" in error_message.lower():
            return SQLExecutionErrorType.INVALID_IDENTIFIER
        elif "permission denied" in error_message.lower():
            return SQLExecutionErrorType.PERMISSION_ERROR
        elif "connection" in error_message.lower():
            return SQLExecutionErrorType.CONNECTION_ERROR
        else:
            return SQLExecutionErrorType.OTHER

    def correct_query(self, query: str, error_message: str, schema: str) -> str:
        correction_prompt = ChatPromptTemplate.from_messages([
            (
                "system", 
                "You are an expert SQL query corrector. Given a failed SQL query, error message, and database schema, "
                "correct the query to resolve the error. Generate only the corrected SQL query without any additional text or explanation. "
                "Ensure that the query adheres to the schema and follows the correct data formats."
            ),
            (
                "user", 
                "Failed Query: {query}\n\n"
                "Error Message: {error}\n\n"
                "Database Schema:\n{schema}\n\n"
                "Additional Info: The CLASSES table uses 'Spring YYYY Semester' or 'Fall YYYY Semester' format for terms. "
                "Course codes are typically in the format 'SUBJ NNNN'.\n\n"
                "Please correct the SQL query to resolve the error and ensure it follows the correct schema and data formats. "
                "Return only the corrected SQL query."
            )
        ])

        response = self.llm.invoke(correction_prompt.format(
            query=query,
            error=error_message,
            schema=schema
        ))
        return response.content.strip()

    def execute_query_with_retry(self, query: str, schema: str, max_retries: int = 3) -> Tuple[Any, str]:
        for attempt in range(max_retries):
            try:
                result = self.db_query(query)
                if isinstance(result, dict) and "error" in result:
                    raise Exception(result["error"])
                return result, query
            except Exception as e:
                error_message = str(e)
                error_type = self.classify_error(error_message)
                
                if error_type in [SQLExecutionErrorType.SYNTAX_ERROR, SQLExecutionErrorType.INVALID_IDENTIFIER]:
                    query = self.correct_query(query, error_message, schema)
                elif error_type == SQLExecutionErrorType.PERMISSION_ERROR:
                    return None, f"Permission error: {error_message}"
                elif error_type == SQLExecutionErrorType.CONNECTION_ERROR:
                    return None, f"Connection error: {error_message}"
                else:
                    if attempt == max_retries - 1:
                        return None, f"Query execution failed after {max_retries} attempts: {error_message}"
        
        return None, f"Query execution failed after {max_retries} attempts"

    def process(self, state: AgentState) -> AgentState:
        print("DEBUG: Executing sql agent")
        
        schema = self.get_schema()
        course_codes = []
        if state.get("course_description_results"):
            course_codes = [result["course_code"] for result in state["course_description_results"] if result["course_code"] != "Unknown"]
        
        generated_query = self.generate_query(state["query"], schema, course_codes)

        if not generated_query:
            state["sql_results"] = {"error": "No valid query generated to execute."}
        else:
            state["generated_query"] = generated_query
            results, final_query = self.execute_query_with_retry(generated_query, schema)
            state["sql_results"] = results
            state["generated_query"] = final_query

        state["visited_nodes"].append("sql_agent")
        state["messages"].append({
            "role": "assistant",
            "content": f"SQL query execution completed. Results: {state['sql_results']}"
        })

        return state

def sql_agent_node(state: AgentState) -> AgentState:
    agent = SQLAgent()
    return agent.process(state)

def test_sql_agent(query: str):
    state = create_agent_state(query)
    state["course_description_results"] = [
        {"course_code": "INFO 7250", "course_name": "Engineering of Big-Data Systems"},
        {"course_code": "INFO 7255", "course_name": "Advanced Big-Data Applications and Indexing Techniques"}
    ]
    agent = SQLAgent()
    final_state = agent.process(state)

    print("\n--- SQL Agent Test Results ---")
    print(f"Query: {query}")
    print(f"Generated SQL Query: {final_state.get('generated_query', 'N/A')}")
    print(f"SQL Results: {final_state.get('sql_results', 'N/A')}")
    print(f"Visited Nodes: {final_state.get('visited_nodes', [])}")

if __name__ == "__main__":
    test_query = "What instructors we have for DAMG7245 upcoming term"
    test_sql_agent(test_query)